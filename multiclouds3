/***
 * Multi-Cloud S3 Index - Cloudflare Workers
 * Unified interface for ImpossibleCloud + Wasabi with MKV support, routing, and error handling
 *
 * REWRITTEN VERSION:
 * - Implements auto-detection routing based on URL path prefixes (e.g., /impossible/ or /wasabi/).
 * - Removes query-param based switching (?switch=)
 * - Centralizes routing logic in the main fetch() handler.
 * - BUG FIX (2025-10-20): Correctly prepends routing prefix to folder links in parseListBucketResult.
 ***/

const CONFIG = {
  siteName: "Multi-Cloud S3 Index",
  siteIcon: "üå§Ô∏è",
  theme: "dark",
  defaultPath: "",
  passwordProtected: false,
  password: "",
  experimentalMkvSupport: true,
  // This strategy is now enforced by the code structure.
  routingStrategy: "path-based",
  pathRouting: {
    "impossible/": "impossiblecloud",
    "wasabi/": "wasabi",
    default: "impossiblecloud"
  },
  providerPriority: ["impossiblecloud", "wasabi"]
};

const PROVIDERS = {
  impossiblecloud: {
    name: "ImpossibleCloud",
    icon: "‚òÅÔ∏è",
    description: "üá™üá∫ European ‚Ä¢ Zero Egress Fees",
    endpoints: {
      "eu-central-2": "eu-central-2.storage.impossibleapi.net",
      "eu-west-1": "eu-west-1.storage.impossibleapi.net",
      "eu-west-2": "eu-west-2.storage.impossibleapi.net",
      "eu-east-1": "eu-east-1.storage.impossibleapi.net",
      "eu-north-1": "eu-north-1.storage.impossibleapi.net"
    },
    defaultRegion: "eu-central-2"
  },
  wasabi: {
    name: "Wasabi",
    icon: "ü™£",
    description: "üåç Global ‚Ä¢ Hot Cloud Storage",
    endpoints: {
      "us-east-1": "s3.wasabisys.com",
      "us-east-2": "s3.us-east-2.wasabisys.com",
      "us-west-1": "s3.us-west-1.wasabisys.com",
      "eu-central-1": "s3.eu-central-1.wasabisys.com",
      "eu-central-2": "s3.eu-central-2.wasabisys.com",
      "eu-west-1": "s3.eu-west-1.wasabisys.com",
      "eu-west-2": "s3.eu-west-2.wasabisys.com",
      "ap-northeast-1": "s3.ap-northeast-1.wasabisys.com",
      "ap-northeast-2": "s3.ap-northeast-2.wasabisys.com",
      "ap-southeast-1": "s3.ap-southeast-1.wasabisys.com",
      "ap-southeast-2": "s3.ap-southeast-2.wasabisys.com"
    },
    defaultRegion: "us-east-1"
  }
};

export default {
  async fetch(request, env) {
    try {
      const url = new URL(request.url);
      // This is the full path, including prefixes like "impossible/"
      const rawPath = decodeURIComponent(url.pathname).replace(/^\//, "");

      // Handle favicon
      if (url.pathname === "/favicon.ico") {
        return serveFavicon();
      }

      // Password protection enforcement
      if (CONFIG.passwordProtected && !await checkAuth(request, CONFIG.password)) {
        return new Response(getPasswordPage(), {
          status: 401,
          headers: {
            "Content-Type": "text/html",
            "WWW-Authenticate": 'Basic realm="Multi-Cloud S3 Index"'
          }
        });
      }

      // === NEW: Auto-detection routing ===
      // Determine provider and the path *without* the prefix
      const { provider, cleanPath } = determineProviderAndCleanPath(rawPath);
      // Get the configuration for the determined provider
      const providerConfig = getProviderConfig(env, provider);
      // ===================================

      // URL search params route to download, preview, stream, or browse
      // Note: We now pass providerConfig and cleanPath to all handlers.
      if (url.searchParams.has("download")) {
        return await handleDownload(providerConfig, cleanPath, request);
      } else if (url.searchParams.has("preview")) {
        return await handlePreview(providerConfig, cleanPath, request);
      } else if (url.searchParams.has("stream")) {
        return await handleStream(providerConfig, cleanPath, request);
      } else {
        // We pass rawPath for breadcrumbs, cleanPath for S3 listing
        return await handleBrowse(providerConfig, cleanPath, rawPath, request);
      }
    } catch (error) {
      console.error("Multi-Cloud Error:", error);
      return new Response(getErrorPage(error.message || "Multi-Cloud Error"), {
        status: error.status || 500,
        headers: {
          "Content-Type": "text/html"
        }
      });
    }
  }
};

// --- NEW HELPER FUNCTION ---
/**
 * Determines the S3 provider and the clean file path based on URL prefixes.
 * @param {string} path The raw URL path (e.g., "impossible/movies/file.mp4")
 * @returns {{provider: string, cleanPath: string}}
 */
function determineProviderAndCleanPath(path) {
  for (const [prefix, provider] of Object.entries(CONFIG.pathRouting)) {
    if (prefix !== "default" && path.startsWith(prefix)) {
      // Return the provider and the path *without* the prefix
      return { provider, cleanPath: path.slice(prefix.length) };
    }
  }
  // Default provider if no prefix matches
  return { provider: CONFIG.pathRouting.default, cleanPath: path };
}

// --- CORE HELPER FUNCTIONS ---

function serveFavicon() {
  // Transparent 16x16 png icon base64 encoded
  const faviconBase64 = "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACFElEQVQ4T2NkwA3+gwEYjIwMUsAABF9Q5NMjAfMgFZmKIMHzAxgj8U7bZEQ/ClWDCWoA/0G+ByVZnYMBpGcSDoQRSJkARgJzHgMsaaAzEg2zDMC6BSpkOu4VwM0LGFgAAYzKRQKCACJMJWdgQZqukC7LQHkguAEEagHEWVU7og7C4YwAiYQiK+RYYGZAEirEXVYtAFpCECJnQnoA9G+gEEb/AC18WfBhgVhPgDIbHgskB83GdCXYLhBlGLgJwHsAUE1IMhIiZGFpA7FBo6jLDBAzMDAwETGBZAYzLAFIhcLhUCGHRBAlIu0kbBpgDJ3BqAAYBmWTiLNNINajQwEcK2EyIG8Z2QFIgsgwGgQbIBQBZQGBG0ClBfCGJZAUGp4CN9YWBAADECIEA4VkpHiAAAAAElFTkSuQmCC";
  return new Response(Uint8Array.from(atob(faviconBase64), c => c.charCodeAt(0)), {
    status: 200,
    headers: {
      "Content-Type": "image/png",
      "Cache-Control": "public, max-age=604800"
    }
  });
}

async function checkAuth(request, password) {
  const authHeader = request.headers.get("Authorization");
  if (!authHeader) return false;
  const [scheme, encoded] = authHeader.split(" ");
  if (scheme !== "Basic") return false;
  const decoded = atob(encoded);
  const [username, pwd] = decoded.split(":");
  return pwd === password;
}

function getProviderConfig(env, provider) {
  const providerInfo = PROVIDERS[provider];
  if (!providerInfo) {
    throw { message: `Unknown provider: ${provider}`, status: 400 };
  }

  const config = {
    provider: provider,
    name: providerInfo.name,
    icon: providerInfo.icon,
    description: providerInfo.description
  };

  if (provider === "impossiblecloud") {
    config.accessKey = env.IMPOSSIBLE_ACCESS_KEY_ID;
    config.secretKey = env.IMPOSSIBLE_SECRET_ACCESS_KEY;
    config.bucket = env.IMPOSSIBLE_BUCKET_NAME;
    config.region = env.IMPOSSIBLE_REGION || providerInfo.defaultRegion;
  } else if (provider === "wasabi") {
    config.accessKey = env.WASABI_ACCESS_KEY_ID;
    config.secretKey = env.WASABI_SECRET_ACCESS_KEY;
    config.bucket = env.WASABI_BUCKET_NAME;
    config.region = env.WASABI_REGION || providerInfo.defaultRegion;
  }

  config.endpoint = providerInfo.endpoints[config.region] || providerInfo.endpoints[providerInfo.defaultRegion];

  if (!config.accessKey || !config.secretKey || !config.bucket || !config.endpoint) {
    throw {
      message: `Incomplete configuration for ${providerInfo.name}. Please check environment variables.`,
      status: 500,
    };
  }
  return config;
}

// --- AWSv4 SIGNING ---

function awsUriEncode(str, encodeSlash = true) {
  let encoded = encodeURIComponent(str).replace(/[!'()*]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`);
  if (!encodeSlash) {
    encoded = encoded.replace(/%2F/g, "/");
  }
  return encoded;
}

function createCanonicalQueryString(params) {
  const sortedKeys = Object.keys(params).sort();
  return sortedKeys.map((key) => `${awsUriEncode(key)}=${awsUriEncode(params[key])}`).join("&");
}

async function signRequest(providerConfig, method, path, queryParams = {}, payload = "") {
  const service = "s3";
  const endpoint = `${providerConfig.bucket}.${providerConfig.endpoint}`;

  const now = new Date();
  const dateStamp = now.toISOString().replace(/[:\-]|\.\d{3}/g, "").slice(0, 8);
  const amzDate = now.toISOString().replace(/[:\-]|\.\d{3}/g, "");

  const payloadHash = await sha256(payload);

  const pathSegments = path.split("/").map((segment) => awsUriEncode(segment, true));
  const canonicalUri = path ? "/" + pathSegments.join("/") : "/";

  const canonicalQueryString = createCanonicalQueryString(queryParams);

  const canonicalHeaders = `host:${endpoint}\nx-amz-content-sha256:${payloadHash}\nx-amz-date:${amzDate}\n`;
  const signedHeaders = "host;x-amz-content-sha256;x-amz-date";

  const canonicalRequest = `${method}\n${canonicalUri}\n${canonicalQueryString}\n${canonicalHeaders}\n${signedHeaders}\n${payloadHash}`;

  const algorithm = "AWS4-HMAC-SHA256";
  const credentialScope = `${dateStamp}/${providerConfig.region}/${service}/aws4_request`;
  const stringToSign = `${algorithm}\n${amzDate}\n${credentialScope}\n${await sha256(canonicalRequest)}`;

  const signingKey = await getSignatureKey(providerConfig.secretKey, dateStamp, providerConfig.region, service);
  const signature = await hmacSha256(signingKey, stringToSign);

  const authorizationHeader = `${algorithm} Credential=${providerConfig.accessKey}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${signature}`;

  const urlParams = new URLSearchParams(queryParams);
  const urlString = `https://${endpoint}${canonicalUri}${urlParams.toString() ? "?" + urlParams.toString() : ""}`;

  return {
    url: urlString,
    headers: {
      Host: endpoint,
      "x-amz-date": amzDate,
      "x-amz-content-sha256": payloadHash,
      Authorization: authorizationHeader,
    },
  };
}

// --- CRYPTO HELPERS ---

async function sha256(message) {
  const msgBuffer = new TextEncoder().encode(message);
  const hashBuffer = await crypto.subtle.digest("SHA-256", msgBuffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}

async function hmacSha256(key, message) {
  const encoder = new TextEncoder();
  const keyData = typeof key === "string" ? encoder.encode(key) : key;
  const cryptoKey = await crypto.subtle.importKey("raw", keyData, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
  const signature = await crypto.subtle.sign("HMAC", cryptoKey, encoder.encode(message));
  const hashArray = Array.from(new Uint8Array(signature));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}

async function getSignatureKey(key, dateStamp, regionName, serviceName) {
  const encoder = new TextEncoder();
  const kDate = await hmacSha256Raw(encoder.encode("AWS4" + key), dateStamp);
  const kRegion = await hmacSha256Raw(kDate, regionName);
  const kService = await hmacSha256Raw(kRegion, serviceName);
  const kSigning = await hmacSha256Raw(kService, "aws4_request");
  return kSigning;
}

async function hmacSha256Raw(key, message) {
  const encoder = new TextEncoder();
  const keyData = typeof key === "string" ? encoder.encode(key) : key;
  const cryptoKey = await crypto.subtle.importKey("raw", keyData, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
  const signature = await crypto.subtle.sign("HMAC", cryptoKey, encoder.encode(message));
  return new Uint8Array(signature);
}

// --- S3 API HELPERS ---

async function listObjects(providerConfig, prefix = "", delimiter = "/") {
  const queryParams = {
    "list-type": "2",
    delimiter,
    "max-keys": "1000",
  };

  if (prefix) {
    queryParams.prefix = prefix;
  }

  const { url, headers } = await signRequest(providerConfig, "GET", "", queryParams);

  const response = await fetch(url, { headers });

  if (!response.ok) {
    const text = await response.text();
    throw { message: `Failed to list objects from ${providerConfig.name}: ${text}`, status: response.status };
  }

  const xmlText = await response.text();
  return parseListBucketResult(xmlText, providerConfig);
}

//
// === THIS FUNCTION IS NOW FIXED ===
//
function parseListBucketResult(xml, providerConfig) {
  const folders = [];
  const files = [];

  // --- FIX ---
  // Find the routing prefix for the CURRENT provider ONCE
  const routingPrefix = Object.keys(CONFIG.pathRouting).find(
      k => CONFIG.pathRouting[k] === providerConfig.provider
  ) || "";
  // -----------

  const prefixMatches = xml.matchAll(/<CommonPrefixes>.*?<Prefix>(.*?)<\/Prefix>.*?<\/CommonPrefixes>/gs);
  for (const match of prefixMatches) {
    const prefix = match[1]; // This is the S3 key, e.g., "movies/"
    const name = prefix.replace(/\/$/, "").split("/").pop();
    
    // --- FIX ---
    // Create the full link path, e.g., "wasabi/" + "movies/"
    const fullLinkPrefix = routingPrefix + prefix; 
    
    // Use the 'fullLinkPrefix' for the href
    folders.push({ name, prefix: fullLinkPrefix, provider: providerConfig.provider });
  }

  const contentMatches = xml.matchAll(/<Contents>(.*?)<\/Contents>/gs);
  for (const match of contentMatches) {
    const content = match[1];
    const keyMatch = content.match(/<Key>(.*?)<\/Key>/);
    const sizeMatch = content.match(/<Size>(.*?)<\/Size>/);
    const modifiedMatch = content.match(/<LastModified>(.*?)<\/LastModified>/);

    if (keyMatch) {
      const key = keyMatch[1];
      if (key.endsWith("/")) continue; // Skip folders listed in Contents

      const name = key.split("/").pop();
      const size = sizeMatch ? parseInt(sizeMatch[1]) : 0;
      const lastModified = modifiedMatch ? modifiedMatch[1] : "";
      
      // --- FIX ---
      // 'routingPrefix' is already defined above
      // -----------
      
      files.push({
        name,
        key: routingPrefix + key, // Prepend the prefix for correct link generation
        size,
        lastModified,
        provider: providerConfig.provider,
        providerName: providerConfig.name,
        providerIcon: providerConfig.icon,
      });
    }
  }

  return { folders, files };
}
//
// === END OF FIX ===
//

// --- ROUTE HANDLERS (SIMPLIFIED) ---

/**
 * Handles file downloads.
 * Assumes providerConfig and cleanPath are already determined.
 */
async function handleDownload(providerConfig, cleanPath, request) {
  if (!cleanPath) {
    throw { message: "No file path provided", status: 400 };
  }

  const { url, headers } = await signRequest(providerConfig, "GET", cleanPath, {});

  const response = await fetch(url, { headers });

  if (!response.ok) {
    const errorText = await response.text();
    throw { message: `Download failed from ${providerConfig.name}: ${response.status}`, status: response.status };
  }

  const fileName = cleanPath.split("/").pop();
  const fileType = fileName.split(".").pop().toLowerCase();
  const contentType = getContentType(fileType);

  return new Response(response.body, {
    headers: {
      "Content-Type": contentType,
      "Content-Disposition": `attachment; filename="${fileName}"`,
      "Cache-Control": "public, max-age=3600",
      "Accept-Ranges": "bytes",
      "X-Provider": providerConfig.name,
    },
  });
}

/**
 * Handles file streaming (video/audio).
 * Assumes providerConfig and cleanPath are already determined.
 */
async function handleStream(providerConfig, cleanPath, request) {
  if (!cleanPath) {
    throw { message: "No file path provided", status: 400 };
  }

  const { url, headers } = await signRequest(providerConfig, "GET", cleanPath, {});

  const response = await fetch(url, { headers });

  if (!response.ok) {
    throw { message: `Stream failed from ${providerConfig.name}: ${response.status}`, status: response.status };
  }

  const fileName = cleanPath.split("/").pop();
  const fileType = fileName.split(".").pop().toLowerCase();

  let contentType = getContentType(fileType);
  if (fileType === "mkv" && CONFIG.experimentalMkvSupport) {
    contentType = "video/webm";
  }

  return new Response(response.body, {
    headers: {
      "Content-Type": contentType,
      "Content-Disposition": `inline; filename="${fileName}"`,
      "Cache-Control": "public, max-age=3600",
      "Accept-Ranges": "bytes",
      "X-Provider": providerConfig.name,
    },
  });
}

/**
 * Handles file previews (images, text, video player page).
 * Assumes providerConfig and cleanPath are already determined.
 */
async function handlePreview(providerConfig, cleanPath, request) {
  if (!cleanPath) {
    throw { message: "No file path provided", status: 400 };
  }

  const fileName = cleanPath.split("/").pop();
  const fileType = fileName.split(".").pop().toLowerCase();

  const videoFormats = ["mp4", "webm", "mkv", "avi", "mov"];
  if (videoFormats.includes(fileType)) {
    const userAgent = request.headers.get("User-Agent") || "";
    // Find the routing prefix for this provider
    const routingPrefix = Object.keys(CONFIG.pathRouting).find(
      k => CONFIG.pathRouting[k] === providerConfig.provider
    ) || "";
    const rawPath = routingPrefix + cleanPath; // Rebuild raw path for the stream URL
    
    // Pass the *rawPath* so the stream URL is correct
    const html = await handleVideoPreview(rawPath, fileName, fileType, userAgent);
    return new Response(html, { headers: { "Content-Type": "text/html" }});
  }

  // For non-video files, fetch and return directly
  const { url, headers } = await signRequest(providerConfig, "GET", cleanPath, {});
  const response = await fetch(url, { headers });

  if (!response.ok) {
    throw { message: `Preview failed from ${providerConfig.name}: ${response.status}`, status: response.status };
  }

  const contentType = getContentType(fileType);

  return new Response(response.body, {
    headers: {
      "Content-Type": contentType,
      "Content-Disposition": `inline; filename="${fileName}"`,
      "Cache-Control": "public, max-age=3600",
      "X-Provider": providerConfig.name,
    },
  });
}

/**
 * Generates the HTML page for video previews.
 * Needs the 'rawPath' to build the correct streaming URL.
 */
async function handleVideoPreview(rawPath, fileName, fileType, userAgent) {
  const isFirefox = userAgent.toLowerCase().includes("firefox");
  const isChrome = userAgent.toLowerCase().includes("chrome");
  const isSafari = userAgent.toLowerCase().includes("safari") && !isChrome;

  // The stream URL is the file's own path plus "?stream"
  const streamUrl = "/" + rawPath + "?stream";

  let browserInfo = "";
  if (fileType === "mkv") {
    if (isFirefox) {
      browserInfo = `
        <div class="info-box firefox">
          <strong>ü¶ä Firefox Detected</strong><br>
          Your browser supports MKV files with VP8, VP9, AV1, and H.264 codecs.
          If playback fails, the file may use unsupported audio codecs (e.g., AC3, DTS).
        </div>`;
    } else if (isChrome) {
      browserInfo = `
        <div class="info-box chrome">
          <strong>üåê Chrome Detected</strong><br>
          Chrome can play some MKV files with WebM-compatible codecs (VP8/VP9 + Opus/Vorbis).
          If playback fails, try downloading the file or use Firefox for better MKV support.
        </div>`;
    } else if (isSafari) {
      browserInfo = `
        <div class="warning">
          <strong>‚ö†Ô∏è Safari Detected</strong><br>
          Safari has very limited MKV support. We recommend downloading the file
          or using Firefox/Chrome for better compatibility.
        </div>`;
    } else {
      browserInfo = `
        <div class="info-box">
          <strong>‚ÑπÔ∏è MKV Playback</strong><br>
          Browser support varies. Firefox 2025+ has the best native MKV support.
          If playback fails, try downloading or using a different browser.
        </div>`;
    }
  }

  // (HTML for video player is identical to your original code)
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Video Player - ${fileName}</title>
  <style>
    body {
      background: #000;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
        sans-serif;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    video {
      width: 100%;
      max-height: 70vh;
      border-radius: 8px;
    }
    .info-box,
    .warning {
      padding: 15px 20px;
      margin-bottom: 20px;
      border-radius: 6px;
      font-size: 14px;
      line-height: 1.6;
    }
    .info-box {
      background: #2196f3;
      color: #fff;
    }
    .info-box.firefox {
      background: #ff7139;
    }
    .info-box.chrome {
      background: #4285f4;
    }
    .warning {
      background: #ff9800;
      color: #000;
    }
  </style>
</head>
<body>
  ${browserInfo}
  <video controls preload="metadata" playsinline>
    ${
      fileType === "mkv"
        ? `<source src="${streamUrl}" type="video/webm; codecs=vp9,opus" />
            <source src="${streamUrl}" type="video/webm; codecs=vp8,opus" />
            <source src="${streamUrl}" type="video/x-matroska" />`
        : `<source src="${streamUrl}" type="video/${
            fileType === "mp4" ? "mp4" : fileType === "webm" ? "webm" : "quicktime"
          }" />`
    }
    Your browser does not support the video tag or this video format.
  </video>
</body>
</html>`;
}

/**
 * Handles browsing folders.
 * Assumes providerConfig is determined.
 * Uses cleanPath for S3 prefix and rawPath for breadcrumbs.
 */
async function handleBrowse(providerConfig, cleanPath, rawPath, request) {
  // Use the cleanPath for the S3 prefix
  const prefix = cleanPath ? (cleanPath.endsWith("/") ? cleanPath : cleanPath + "/") : "";

  let result;
  try {
    result = await listObjects(providerConfig, prefix);
  } catch (error) {
    // Basic error handling if listObjects fails
    throw error;
  }

  // Use the rawPath for the breadcrumbs
  const html = getBrowsePage(rawPath, result.folders, result.files, providerConfig);

  return new Response(html, {
    headers: {
      "Content-Type": "text/html; charset=utf-8",
      "Cache-Control": "public, max-age=300", // Short cache for directory listings
    },
  });
}

// --- HTML PAGE GENERATORS ---

function getContentType(ext) {
  const types = {
    html: "text/html", htm: "text/html", txt: "text/plain", css: "text/css",
    js: "text/javascript", json: "application/json", xml: "text/xml",
    jpg: "image/jpeg", jpeg: "image/jpeg", png: "image/png", gif: "image/gif",
    svg: "image/svg+xml", ico: "image/x-icon", webp: "image/webp",
    mp4: "video/mp4", webm: "video/webm", mkv: "video/x-matroska",
    avi: "video/x-msvideo", mov: "video/quicktime",
    mp3: "audio/mpeg", wav: "audio/wav", ogg: "audio/ogg",
    m4a: "audio/mp4", flac: "audio/flac",
    pdf: "application/pdf", doc: "application/msword",
    docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    xls: "application/vnd.ms-excel",
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    ppt: "application/vnd.ms-powerpoint",
    pptx: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    zip: "application/zip", rar: "application/x-rar-compressed",
    "7z": "application/x-7z-compressed", tar: "application/x-tar", gz: "application/gzip",
  };
  return types[ext] || "application/octet-stream";
}

function formatSize(bytes) {
  if (bytes === 0) return "0 B";
  const k = 1024;
  const sizes = ["B", "KB", "MB", "GB", "TB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
}

function formatDate(dateString) {
  const date = new Date(dateString);
  return date.toLocaleString();
}

function getFileIcon(name) {
  const ext = name.split(".").pop().toLowerCase();
  const icons = {
    pdf: "üìÑ", doc: "üìù", docx: "üìù", txt: "üìù",
    xls: "üìä", xlsx: "üìä", csv: "üìä",
    ppt: "üìΩÔ∏è", pptx: "üìΩÔ∏è",
    jpg: "üñºÔ∏è", jpeg: "üñºÔ∏è", png: "üñºÔ∏è", gif: "üñºÔ∏è", svg: "üñºÔ∏è", webp: "üñºÔ∏è",
    mp4: "üé¨", avi: "üé¨", mkv: "üé¨", mov: "üé¨", webm: "üé¨",
    mp3: "üéµ", wav: "üéµ", ogg: "üéµ", flac: "üéµ", m4a: "üéµ",
    zip: "üì¶", rar: "üì¶", "7z": "üì¶", tar: "üì¶", gz: "üì¶",
    js: "üíª", py: "üíª", java: "üíª", cpp: "üíª", html: "üíª", css: "üíª",
  };
  return icons[ext] || "üìÑ";
}

function getBrowsePage(currentPath, folders, files, providerConfig = null) {
  // Breadcrumbs are built from the raw path
  const pathParts = currentPath ? currentPath.split("/").filter((p) => p) : [];
  const breadcrumbs = pathParts
    .map((part, index) => {
      const path = "/" + pathParts.slice(0, index + 1).join("/");
      return `<a href="${path}">${part}</a>`;
    })
    .join(" / ");

  // Provider Switcher uses <a> links
  const providerSwitcher = `
    <div class="provider-switcher">
      <span class="label">üå§Ô∏è Provider:</span>
      ${Object.entries(CONFIG.pathRouting)
        .filter(([prefix, provider]) => prefix !== 'default') // Don't show 'default' as a button
        .map(
          ([prefix, providerKey]) => {
            const p = PROVIDERS[providerKey];
            if (!p) return '';
            // Create a link to the root prefix
            return `<a href="/${prefix}" class="provider-btn ${
              providerConfig?.provider === providerKey ? "active" : ""
            }" title="${p.description}">${p.icon} ${p.name}</a>`
          }
        )
        .join("")}
      <span class="strategy">Strategy: ${CONFIG.routingStrategy}</span>
    </div>`;

  const folderRows = folders
    .map(
      (folder) => `
    <tr class="folder-row ${folder.error ? "error-row" : ""}">
      <td class="icon">üìÅ</td>
      <td class="name"><a href="/${folder.prefix}">${folder.name}</a></td>
      <td class="size">-</td>
      <td class="modified">-</td>
      <td class="provider">${folder.error ? "‚ùå" : PROVIDERS[folder.provider]?.icon || ""}</td>
      <td class="actions"><a href="/${folder.prefix}" class="btn">Open</a></td>
    </tr>`
    )
    .join("");

  const fileRows = files
    .map(
      (file) => `
    <tr class="file-row">
      <td class="icon">${getFileIcon(file.name)}</td>
      <td class="name">${file.name}</td>
      <td class="size">${formatSize(file.size)}</td>
      <td class="modified">${formatDate(file.lastModified)}</td>
      <td class="provider" title="${file.providerName || ""}">${file.providerIcon || ""}</td>
      <td class="actions">
        <a href="/${file.key}?download" class="btn btn-download">Download</a>
        ${isPreviewable(file.name) ? `<a href="/${file.key}?preview" class="btn btn-preview">Preview</a>` : ""}
      </td>
    </tr>`
    )
    .join("");

  const currentProviderInfo = providerConfig
    ? `<div class="current-provider">${providerConfig.icon} Currently browsing <strong>${providerConfig.name}</strong> ‚Ä¢ ${providerConfig.description}</div>`
    : "";

  // (HTML and CSS are identical to your original code)
  return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>${CONFIG.siteName}</title>
<style>
/* Styles same as previously defined in last response */
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  background: ${CONFIG.theme === "dark" ? "#1a1a1a" : "#f5f5f5"};
  color: ${CONFIG.theme === "dark" ? "#e0e0e0" : "#333"};
  padding: 20px;
  line-height: 1.6;
}
.container {
  max-width: 1400px;
  margin: 0 auto;
}
header {
  display: flex;
  align-items: center;
  margin-bottom: 20px;
  padding-bottom: 20px;
  border-bottom: 2px solid ${CONFIG.theme === "dark" ? "#333" : "#ddd"};
}
.site-icon {
  font-size: 48px;
  margin-right: 20px;
}
h1 {
  font-size: 32px;
  font-weight: 600;
}
.subtitle {
  font-size: 14px;
  color: ${CONFIG.theme === "dark" ? "#888" : "#666"};
  margin-top: 5px;
}
.provider-switcher {
  background: ${CONFIG.theme === "dark" ? "#252525" : "#fff"};
  padding: 15px 20px;
  border-radius: 8px;
  margin-bottom: 15px;
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
}
.provider-switcher .label {
  font-weight: 600;
}
.provider-btn {
  /* This is now an <a> tag, but styled as a button */
  display: inline-block;
  text-decoration: none;
  padding: 8px 15px;
  border: 2px solid ${CONFIG.theme === "dark" ? "#444" : "#ddd"};
  background: transparent;
  color: ${CONFIG.theme === "dark" ? "#e0e0e0" : "#333"};
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  transition: all 0.2s;
}
.provider-btn:hover {
  border-color: #0066cc;
}
.provider-btn.active {
  background: #0066cc;
  color: white;
  border-color: #0066cc;
}
.strategy {
  margin-left: auto;
  font-size: 12px;
  color: ${CONFIG.theme === "dark" ? "#888" : "#666"};
  background: ${CONFIG.theme === "dark" ? "#333" : "#f0f0f0"};
  padding: 4px 8px;
  border-radius: 4px;
}
.current-provider {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 12px 20px;
  border-radius: 8px;
  margin-bottom: 15px;
  text-align: center;
  font-size: 14px;
}
.breadcrumb {
  background: ${CONFIG.theme === "dark" ? "#252525" : "#fff"};
  padding: 15px 20px;
  border-radius: 8px;
  margin-bottom: 20px;
  font-size: 14px;
}
.breadcrumb a {
  color: #0066cc;
  text-decoration: none;
  transition: color 0.2s;
}
.breadcrumb a:hover {
  color: #0052a3;
  text-decoration: underline;
}
table {
  width: 100%;
  background: ${CONFIG.theme === "dark" ? "#252525" : "#fff"};
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}
th {
  background: ${CONFIG.theme === "dark" ? "#1e1e1e" : "#f8f8f8"};
  padding: 15px;
  text-align: left;
  font-weight: 600;
  border-bottom: 2px solid ${CONFIG.theme === "dark" ? "#333" : "#e0e0e0"};
}
td {
  padding: 12px 15px;
  border-bottom: 1px solid ${CONFIG.theme === "dark" ? "#333" : "#f0f0f0"};
}
tr:last-child td {
  border-bottom: none;
}
tr:hover {
  background: ${CONFIG.theme === "dark" ? "#2a2a2a" : "#f9f9f9"};
}
.error-row {
  background: ${CONFIG.theme === "dark" ? "#2a1a1a" : "#fff5f5"};
}
.icon {
  width: 40px;
  text-align: center;
  font-size: 20px;
}
.name {
  font-weight: 500;
}
.name a {
  color: ${CONFIG.theme === "dark" ? "#4d9fff" : "#0066cc"};
  text-decoration: none;
}
.name a:hover {
  text-decoration: underline;
}
.size {
  width: 100px;
}
.modified {
  width: 180px;
  font-size: 13px;
  color: ${CONFIG.theme === "dark" ? "#888" : "#666"};
}
.provider {
  width: 40px;
  text-align: center;
  font-size: 18px;
}
.actions {
  width: 220px;
  white-space: nowrap;
}
.btn {
  display: inline-block;
  padding: 6px 12px;
  margin-right: 5px;
  background: #0066cc;
  color: white;
  text-decoration: none;
  border-radius: 4px;
  font-size: 12px;
  transition: background 0.2s;
}
.btn:hover {
  background: #0052a3;
}
.btn-preview {
  background: #28a745;
}
.btn-preview:hover {
  background: #218838;
}
.empty {
  text-align: center;
  padding: 60px 20px;
  color: ${CONFIG.theme === "dark" ? "#666" : "#999"};
}
footer {
  text-align: center;
  margin-top: 40px;
  padding-top: 20px;
  border-top: 1px solid ${CONFIG.theme === "dark" ? "#333" : "#ddd"};
  color: ${CONFIG.theme === "dark" ? "#666" : "#999"};
  font-size: 14px;
}
.stats {
  background: ${CONFIG.theme === "dark" ? "#252525" : "#fff"};
  padding: 15px 20px;
  border-radius: 8px;
  margin-top: 20px;
  display: flex;
  gap: 20px;
  font-size: 14px;
}
.stat {
  display: flex;
  align-items: center;
  gap: 5px;
}
@media (max-width: 768px) {
  .modified {
    display: none;
  }
  .provider {
    display: none;
  }
  .actions {
    width: 150px;
  }
  .btn {
    padding: 5px 8px;
    font-size: 11px;
  }
  .provider-switcher {
    flex-direction: column;
    align-items: flex-start;
  }
}
</style>
</head>
<body>
<div class="container">
  <header>
    <div class="site-icon">${CONFIG.siteIcon}</div>
    <div>
      <h1>${CONFIG.siteName}</h1>
      <div class="subtitle">üå§Ô∏è Unified Multi-Cloud Storage Interface</div>
    </div>
  </header>
  ${providerSwitcher}
  ${currentProviderInfo}
  <div class="breadcrumb">
    <a href="/">üè† Home</a>${breadcrumbs ? " / " + breadcrumbs : ""}
  </div>
  ${
    folders.length === 0 && files.length === 0
      ? `<div class="empty"><h2>üì≠ Empty Folder</h2><p>No files or folders here</p></div>`
      : `<table>
        <thead><tr>
          <th class="icon"></th>
          <th class="name">Name</th>
          <th class="size">Size</th>
          <th class="modified">Modified</th>
          <th class="provider">Provider</th>
          <th class="actions">Actions</th>
        </tr></thead>
        <tbody>${folderRows}${fileRows}</tbody>
      </table>`
  }
  <div class="stats">
    <div class="stat">üìÅ <span>${folders.length} folders</span></div>
    <div class="stat">üìÑ <span>${files.length} files</span></div>
    <div class="stat">üîÑ <span>Strategy: ${CONFIG.routingStrategy}</span></div>
    <div class="stat">‚ö° <span>Providers: ${CONFIG.providerPriority.join(", ")}</span></div>
  </div>
  <footer>
    <p>üå§Ô∏è Multi-Cloud Storage powered by Cloudflare Workers</p>
    <p>${Object.values(PROVIDERS)
      .map((p) => `${p.icon} ${p.name}`)
      .join(" ‚Ä¢ ")}</p>
  </footer>
</div>
</body>
</html>`;
}

function isPreviewable(name) {
  const ext = name.split(".").pop().toLowerCase();
  const previewable = [
    "jpg", "jpeg", "png", "gif", "svg", "webp",
    "pdf", "txt",
    "mp4", "webm", "mkv", "avi", "mov",
    "mp3", "wav", "ogg"
  ];
  return previewable.includes(ext);
}

function getPasswordPage() {
  // (HTML is identical to your original code)
  return `<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Protected - ${CONFIG.siteName}</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        background: #1a1a1a;
        color: #e0e0e0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
      }
      .container {
        text-align: center;
        background: #252525;
        padding: 40px;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }
      h1 {
        margin-bottom: 20px;
      }
      p {
        margin-bottom: 30px;
        color: #999;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üîí Protected Area</h1>
      <p>Please enter the password to access this multi-cloud storage</p>
    </div>
  </body>
  </html>`;
}

function getErrorPage(message) {
  // (HTML is identical to your original code)
  return `<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Error - ${CONFIG.siteName}</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        background: #1a1a1a;
        color: #e0e0e0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
      }
      .container {
        text-align: center;
        background: #252525;
        padding: 40px;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        max-width: 500px;
      }
      h1 {
        color: #ff6b6b;
        margin-bottom: 20px;
      }
      p {
        margin-bottom: 30px;
        word-break: break-word;
      }
      a {
        color: #4d9fff;
        text-decoration: none;
        padding: 10px 20px;
        background: #333;
        border-radius: 6px;
        display: inline-block;
        transition: background 0.2s;
      }
      a:hover {
        background: #444;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>‚ö†Ô∏è Multi-Cloud Error</h1>
      <p>${message}</p>
      <a href="/">‚Üê Back to Home</a>
    </div>
  </body>
  </html>`;
}
